<section class="article">
  <header>
    <h1>Technical Benefits</h1>
    <h2>There are many technical advantages to using Aurelia. In this article, you will find a list of points we think are interesting. Taken together, there is no other SPA framework today that can match Aurelia.</h2>
  </header>

  <article>
    <au-doc-section uid="1" version="1.0.0" heading="Modern JavaScript"><ul>
<li>The only framework fully written in standards-based ES 2015 and ES 2016.</li>
<li>Forward compatible with JavaScript technology that is 2-3 years in the future.</li>
<li>Full support for TypeScript.</li>
</ul>
</au-doc-section>
<au-doc-section uid="2" version="1.0.0" heading="Modern DOM"><ul>
<li>Consistently leverages the most modern DOM APIs.</li>
<li>Bare “to the metal” usage of the DOM; no DOM wrappers in order to ensure maximum performance and memory efficiency.</li>
<li>Automatically polyfills the DOM where appropriate, in order to support older browsers (IE9).</li>
</ul>
</au-doc-section>
<au-doc-section uid="3" version="1.0.0" heading="Modern Tooling"><ul>
<li>Designed to work with modern ES 2015-oriented package managers like JSPM.</li>
<li>Intended to be used with modern transpilers such as Babel and TypeScript.</li>
<li>Supports modern build tooling such as Gulp, out-of-the-box.</li>
<li>Works well with powerful testing tools like Karma and Protractor.</li>
</ul>
</au-doc-section>
<au-doc-section uid="4" version="1.0.0" heading="Code Quality"><ul>
<li>Source code is covered by an extensive suite of unit tests.</li>
<li>All source is fully linted for style and feature-usage consistency throughout.</li>
<li>Code correctness is independently verified by two transpilers: Babel and TypeScript.</li>
<li>TypeScript d.ts files and full API documentation are provided for all libraries.</li>
</ul>
</au-doc-section>
<au-doc-section uid="5" version="1.0.0" heading="Web Component Standards"><ul>
<li>Leverages standards-compliant Web Components specs such as HTMLTemplateElement and ShadowDOM.</li>
<li>Aurelia components can be exported as standards-compliant Web Components for use outside of the framework, in other apps and web pages (soon).</li>
<li>Fully compatible with 3rd-party Web Components, even those originating from other frameworks such as Polymer.</li>
<li>Shields developers from broken or poorly designed aspects of Web Components.</li>
<li>Provides a Web Component-based programming model even on browsers that will never support Web Components (IE).</li>
</ul>
</au-doc-section>
<au-doc-section uid="6" version="1.0.0" heading="Modularity"><ul>
<li>Highly modular development, suitable for large-scale apps.</li>
<li>Native support for feature-based development facilitating parallel development of multiple teams on the same app.</li>
<li>Strong component model for high re-use of UI components across apps.</li>
<li>Export components as spec-compliant Web Components for use in non-Aurelia apps (soon)</li>
</ul>
</au-doc-section>
<au-doc-section uid="7" version="1.0.0" heading="Platform Support"><ul>
<li>Designed for modern web browsers.</li>
<li>Adds polyfills to support older browsers, such as IE9.</li>
<li>A core platform abstraction allows execution of Aurelia in different types of JavaScript environments: browser, NodeJS, Windows Store, etc.</li>
<li>Designed for mobile application development in combination with PhoneGap/Cordova/Crosswalk.</li>
<li>Designed for desktop application development in combination with Electron or NWJS.</li>
</ul>
</au-doc-section>
<au-doc-section uid="8" version="1.0.0" heading="Capabilities"><ul>
<li>Write apps in ES2015/2016/TypeScript.</li>
<li>One simple way of creating components that work in a variety of contexts:
<ul>
<li>Custom Elements</li>
<li>Dynamically Composed UI (data-driven component composition)</li>
<li>Routing/Navigation</li>
<li>Modal Dialogs</li>
<li>Web Components</li>
<li>Progressive Enhancement</li>
<li>Custom scenarios enabled through our Composition Engine</li>
</ul>
</li>
<li>Fully-extensible View Compiler, View Engine and View Resource Pipeline.</li>
<li>Fully-extensible and adaptive data-binding engine.</li>
<li>Powerful and flexible hierarchical dependency injection.</li>
<li>Eager/Lazy/Hybrid loading of all application resources.</li>
<li>Powerful application router with support for encapsulated child routers for multi-team, large-scale development.</li>
<li>Optionally create standards-compliant Web Components or leverage “shielding” from the flaws in the WC specs.</li>
<li>Interoperate with any standards-compliant Web Component.</li>
<li>Loosely coupled cross-component communication via an EventAggregator (Pub/Sub)</li>
<li>Fully customizable application startup and plugin model.</li>
<li>Enables authoring of testable, maintainable and extensible code.</li>
<li>Leverage conventions to write less code and get more done.</li>
<li>Little to no framework intrusion, so developers can focus on their app, not the framework.</li>
<li>Application and package bundling compatible with any build system.</li>
</ul>
</au-doc-section>

  </article>
</section>
